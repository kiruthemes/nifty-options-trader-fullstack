// server/prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id              Int              @id @default(autoincrement())
  email           String           @unique
  password        String
  name            String?

  /// Preferred market data provider for this user ("synthetic" | "dhan" | "kite" | ...)
  dataProvider    String           @default("synthetic")

  /// 1:N User → Strategy (owner)
  strategies      Strategy[]       @relation("UserStrategies")

  /// Last opened strategy (unidirectional 1:1 via unique FK)
  lastStrategyId  Int?             @unique
  lastStrategy    Strategy?        @relation("UserLastStrategy", fields: [lastStrategyId], references: [id])

  /// 1:N User → BrokerAccount
  brokerAccounts  BrokerAccount[]  @relation("UserBrokerAccounts")

  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
}

model Strategy {
  id             Int       @id @default(autoincrement())
  userId         Int
  name           String
  isArchived     Boolean   @default(false)
  defaultLots    Int       @default(1)
  underlying     String    @default("NIFTY")
  atmBasis       String    @default("spot")
  selectedExpiry String?
  realized       Float     @default(0)

  // relations
  user         User    @relation("UserStrategies", fields: [userId], references: [id], onDelete: Cascade)
  // back-reference for User.lastStrategy (separate named relation)
  lastOpenedBy User?   @relation("UserLastStrategy")

  legs    Leg[]
  brokers StrategyBroker[]
  orders  Order[]      // back-reference for Order.strategy

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model Leg {
  id         Int      @id @default(autoincrement())
  strategyId Int

  status String @default("STAGED") // "STAGED" | "OPEN" | "CLOSED"
  side   String                    // "BUY" | "SELL"
  type   String                    // "CE" | "PE"

  strike  Int
  premium Float   @default(0)      // quoted/staged price
  lots    Int     @default(1)
  expiry  String  // "YYYY-MM-DD"

  entryPrice Float?
  exitPrice  Float?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  strategy Strategy @relation(fields: [strategyId], references: [id], onDelete: Cascade)
  Order    Order[]

  @@index([strategyId])
}

model BrokerAccount {
  id             Int              @id @default(autoincrement())
  userId         Int
  provider       String
  label          String?

  // Zerodha (Kite) typically needs key/secret; Dhan relies on access token
  clientId       String?
  apiKey         String?
  apiSecret      String?
  accessToken    String?
  refreshToken   String?
  tokenExpiresAt DateTime?

  // Room for provider-specific metadata (account ID, user hash, etc.)
  metaJson       String           @default("{}")

  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  user           User             @relation("UserBrokerAccounts", fields: [userId], references: [id], onDelete: Cascade)
  links          StrategyBroker[]
  Order          Order[]

  @@index([userId])
  @@index([provider])
}

model StrategyBroker {
  id              Int      @id @default(autoincrement())
  strategyId      Int
  brokerAccountId Int
  enabled         Boolean  @default(true)
  createdAt       DateTime @default(now())

  strategy Strategy      @relation(fields: [strategyId], references: [id], onDelete: Cascade)
  broker   BrokerAccount @relation(fields: [brokerAccountId], references: [id], onDelete: Cascade)

  @@unique([strategyId, brokerAccountId])
  @@index([strategyId])
  @@index([brokerAccountId])
}

model Order {
  id              Int      @id @default(autoincrement())
  strategyId      Int
  legId           Int?
  brokerAccountId Int

  provider        String
  providerOrderId String?
  status          String   @default("PENDING") // "PENDING" | "OPEN" | "REJECTED" | "FILLED" | "CANCELLED"

  requestJson     String   @default("{}")
  responseJson    String   @default("{}")

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  strategy Strategy      @relation(fields: [strategyId], references: [id], onDelete: Cascade)
  leg      Leg?          @relation(fields: [legId], references: [id], onDelete: SetNull)
  broker   BrokerAccount @relation(fields: [brokerAccountId], references: [id], onDelete: Cascade)

  @@index([strategyId])
  @@index([brokerAccountId])
  @@index([provider])
}

model LastFutTick {
  id      Int     @id @default(autoincrement())
  symbol  String  @default("NIFTY") @unique
  expiry  String?
  ltp     Float
  ts      BigInt
  updatedAt DateTime @updatedAt
  @@map("last_fut_tick")
}
